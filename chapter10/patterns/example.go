package main

import (
	"fmt"
	"math/rand"
	"time"
)

func waitForTask() {

	ch := make(chan string)

	// worker thread waits for ask and then executes it.
	go func() {
		task := <-ch
		fmt.Printf("Received clearance papaer. Paper is %s \n", task)
		time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)

	}()

	// This is time required for the manager to get all the paper work.
	time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)
	// manager thread assigns the task.
	ch <- "paper"
	// There's no guarantee if the next line will be printed first or worker line.
	// Guarantee is only around send/receive. Receive happens nanoseconds before send.
	fmt.Printf("manager sent work. \n")
	// wait for the task to complete.
	time.Sleep(1 * time.Second)
}

func waitForResult() {

	ch := make(chan string)

	// worker thread does the heavy lifting and does the work.
	// manager announces the work once it done.
	go func() {
		fmt.Printf("worker started. will send result once the work is complete. \n")
		time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)
		ch <- "work done"
	}()

	// manager thread.
	result := <-ch
	fmt.Printf("manager recieved result %s \n", result)
	time.Sleep(1 * time.Second)

}

func waitForFinished() {
	ch := make(chan struct{})

	// worker thread does the heavy lifting and does the work.
	// manager announces the work once it done.
	go func() {
		fmt.Printf("worker started. will send result once the work is complete. \n")
		time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)
		close(ch)
	}()

	// manager thread.
	_, wd := <-ch
	fmt.Printf("manager recieved result %t \n", wd)
	time.Sleep(1 * time.Second)

}

// This leverages waitForTask.
func poolingPattern() {

	ch := make(chan string)
	const emps = 2
	for emp := 0; emp < emps; emp++ {
		go func(id int) {
			for t := range ch {
				fmt.Printf("worker id %d received task. Performing %s \n", id, t)
				time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)
			}
			fmt.Printf("worker id %d received shutdown signal", id)
		}(emp)
	}

	const work = 10
	for w := 0; w < work; w++ {
		ch <- fmt.Sprintf("%d is passed.\n", w)
	}

	close(ch)
}

// This leverages waitForResult.
func fanOutPattern() {
	const poolSize = 20

	ch := make(chan string, poolSize)

	// Create a bulk of worker pool upfront and assign them the tasks that get
	// generated by the manager.
	for i := 0; i < poolSize; i++ {
		go func(id int) {
			time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)
			ch <- "task done"
			fmt.Printf("worker thread %d. Task performed. \n", id)
		}(i)
	}

	emp := poolSize
	// Manager creates tasks for worker pool to consume.
	for emp > 0 {
		task := <-ch
		fmt.Printf("Ack received. %s Employees pending %d. \n", task, emp)
		emp--
	}

	time.Sleep(1 * time.Second)
}

// This leverages fanOutPattern. This pattern caps the maximum go routines that
// can be at the same time.
func fanOutPatternWithSemaphore() {
	const poolSize = 20

	ch := make(chan string, poolSize)

	sem := make(chan string, 5)
	// Create a bulk of worker pool upfront and assign them the tasks that get
	// generated by the manager.
	for i := 0; i < poolSize; i++ {
		go func(id int) {
			sem <- fmt.Sprintf("%d", id)
			time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)
			ch <- "task done"
			fmt.Printf("worker thread %d. Task performed. \n", id)
			<-sem
		}(i)
	}

	emp := poolSize
	// Manager creates tasks for worker pool to consume.
	for emp > 0 {
		task := <-ch
		fmt.Printf("Ack received. %s Employees pending %d. \n", task, emp)
		emp--
	}

	time.Sleep(1 * time.Second)
}

func dropPattern() {
	ch := make(chan string, 5)

	go func() {
		for p := range ch {
			fmt.Printf("employee is busy with work %s \n", p)
		}
	}()

	for work := 0; work < 20; work++ {
		select {
		case ch <- fmt.Sprintf("%d", work):
			fmt.Println("work is getting assigned.")
		default:
			fmt.Printf("workers are overwhelemd. Dropping the request.\n")
		}
	}

	close(ch)
}

func cancellationPattern() {
	// If this is unbuffered, we will leak go routines.
	ch := make(chan string, 1)

	go func() {
		fmt.Printf("Worker is running. Performing the assigned task.\n")
		time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)
		ch <- "Task done."
	}()

	fmt.Printf("Manager is running. Waiting for 100 milliseconds and moving on.\n")
	tc := time.After(70 * time.Millisecond)
	select {
	case p := <-ch:
		fmt.Printf("Receive completed on channel. Acked the completed work. %s \n", p)
	case t := <-tc:
		fmt.Printf("Unfortunately request timed out.Moving on. %s \n", t)
	}

	time.Sleep(1 * time.Second)
}

func main() {
	waitForResult()
	waitForTask()
	waitForFinished()
	poolingPattern()
	fanOutPatternWithSemaphore()
	fanOutPattern()
	cancellationPattern()
}
